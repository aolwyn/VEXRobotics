#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    PotR,           sensorPotentiometer)
#pragma config(Sensor, in2,    PotL,           sensorPotentiometer)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           DriveR,        tmotorVex393TurboSpeed_MC29, openLoop, reversed, driveRight, encoderPort, I2C_5)
#pragma config(Motor,  port3,           DriveL,        tmotorVex393TurboSpeed_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port4,           SuckL,         tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_3)
#pragma config(Motor,  port5,           SuckR,         tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           Arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Puncher,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           Push,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(0)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

int flag = 0;

void pre_auton()
{
	bStopTasksBetweenModes = true;

	if(SensorValue[PotL] > 2000 && SensorValue[PotR] > 2000)
	{
		flag = 1;//Front Red
	}

	if(SensorValue[PotL] < 2000 && SensorValue[PotR] > 2000)
	{
		flag = 2;//Front Blue
	}

	if(SensorValue[PotL] > 2000 && SensorValue[PotR] < 2000)
	{
		flag = 3;//Back Red
	}

	if(SensorValue[PotL] < 2000 && SensorValue[PotR] < 2000)
	{
		flag = 4;//Back Blue
	}

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Functions
//
/////////////////////////////////////////////////////////////////////////////////////////

//Drive Straight (distance, speed, adjustment)

void driveStraight(int distance, int speed, int adjustment)
{

	while(nMotorEncoder[DriveL] < distance)
	{

		if((abs(nMotorEncoder[DriveR])) < nMotorEncoder[DriveL])
		{
			motor[DriveR] = speed;
			motor[DriveL] = speed - adjustment;
		}
		if((abs(nMotorEncoder[DriveR])) > nMotorEncoder[DriveL])
		{
			motor[DriveR] = speed - adjustment;
			motor[DriveL] = speed;
		}
		if(nMotorEncoder[DriveL] == (abs(nMotorEncoder[DriveR])))
		{
			motor[DriveR] = speed;
			motor[DriveL] = speed;
		}
	}

	motor[DriveR] = 0;
	motor[DriveL] = 0;
}

//Drive Back (distance, speed, adjustment)

void driveBack(int distance, int speed, int adjustment)
{

	while(nMotorEncoder[DriveL] > distance)
	{

		if((abs(nMotorEncoder[DriveR])) < nMotorEncoder[DriveL])
		{
			motor[DriveR] = speed;
			motor[DriveL] = speed - adjustment;
		}
		if((abs(nMotorEncoder[DriveR])) > nMotorEncoder[DriveL])
		{
			motor[DriveR] = speed - adjustment;
			motor[DriveL] = speed;
		}
		if(nMotorEncoder[DriveL] == (abs(nMotorEncoder[DriveR])))
		{
			motor[DriveR] = speed;
			motor[DriveL] = speed;
		}
	}

	motor[DriveR] = 0;
	motor[DriveL] = 0;
}

//Turn Counter Clockwise (speed)

void counter_clockwiseTurn(int speed)
{
	resetMotorEncoder(DriveL);
	resetMotorEncoder(DriveR);

	while(abs(nMotorEncoder[DriveL]) < 125)
	{
		motor[DriveR] = speed;
		motor[DriveL] = -speed;
	}

	motor[DriveR] = 0;
	motor[DriveL] = 0;
}

//Turn Clockwise (speed)

void clockwiseTurn(int speed)
{
	resetMotorEncoder(DriveL);
	resetMotorEncoder(DriveR);

	while(nMotorEncoder[DriveL] < 160)
	{
		motor[DriveR] = -speed;
		motor[DriveL] = speed;
	}

	motor[DriveR] = 0;
	motor[DriveL] = 0;

}

//Turn Sucker ON (length)

void Suck(int length)
{

	resetMotorEncoder(SuckL);

	while(nMotorEncoder[SuckL] < 500)
	{
		motor[SuckL] = 127;
		motor[SuckR] = 127;
	}

	motor[SuckL] = 0;
	motor[SuckR] = 0;
}

//Puncher

void Shoot(int time)
{
	motor[Puncher] = 127;
	wait1Msec(time*1000);


	motor[Puncher] = 0;
}

//Reset Motor Encoders

void resetMotorEncoders()
{
	resetMotorEncoder(DriveL);
	resetMotorEncoder(DriveR);
	resetMotorEncoder(SuckL);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// The "Driver Skills" competition has no autonomous phase. Simply leave the following
// placeholder.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

	if(flag == 1)//Front Red
	{

		//Drive forward to shooting position
		resetMotorEncoders();
		while(nMotorEncoder[DriveL] < 95){
			motor[DriveL] = 40;
		}
		motor[DriveL] = 0;

		//Shoot ball at high flag
		Shoot(1);

		//Drive forward to hit low flag
		while(nMotorEncoder[DriveL] > 0){
			motor[DriveL] = -40;
		}
		motor[DriveL] = 0;
		wait1Msec(1000);
		resetMotorEncoders();
		driveStraight(1275,100,50);
		motor[SuckR] = -127;

		//Drive back to start (next to platform)
		resetMotorEncoders();
		driveBack(-1925,-100,50);

		//Turn left to face wall (90 degree counter-clockwise tank turn)
		resetMotorEncoders();
		while(nMotorEncoder[DriveR] < 300 && nMotorEncoder[DriveL] > -300){
			motor[DriveR] = 127;
			motor[DriveL] = -127;
		}

		//Drive back onto platform
		resetMotorEncoders();
		driveBack(-2000,-127,-30);
		resetMotorEncoders();
		motor[SuckR] = 0;

		/*Old Auton/////////////////////

		driveStraight(2000, 127, 30);//distance, speed, adjustment

		clockwiseTurn(127);//speed
		counter_clockwiseTurn(127);//speed

		Suck(500);//length

		Shoot(3);//time in seconds

		//////////////////////////////*/

	}

	if(flag == 2)//Front Blue
	{

		//Shoot ball at high flag
		resetMotorEncoders();
		while(nMotorEncoder[DriveL] < 45){
			motor[DriveL] = 40;
		}
		motor[DriveL] = 0;

		//Shoot ball at high flag
		Shoot(1);

		//Drive forward to hit low flag
		while(nMotorEncoder[DriveL] > 18){
			motor[DriveL] = -40;
		}
		motor[DriveL] = 0;
		wait1Msec(1000);
		resetMotorEncoders();
		driveStraight(1200,100,50);
		//motor[SuckR] = -127;

		/* DISABLED FOR NOW FOR ALLIES AUTON

		//Drive back to start (next to platform)
		resetMotorEncoders();
		driveBack(-1850,-100,50);
		resetMotorEncoders();

		//Turn left to face wall (90 degree clockwise tank turn)
		resetMotorEncoders();
		while(nMotorEncoder[DriveR] > -300 && nMotorEncoder[DriveL] < 300){
			motor[DriveR] = -127;
			motor[DriveL] = 127;
		}
		resetMotorEncoders();

		//Drive back onto platform
		resetMotorEncoders();
		driveBack(-2000,-127,-30);
		resetMotorEncoders();
		motor[SuckR] = 0;

		*/

		/*Old Auton////////////////////

		Shoot(1); //shoot

		resetMotorEncoders();

		driveStraight (1150, 110, 30); //drive into front flag

		resetMotorEncoders();

		driveBack (-1000, -110, -30); //drive to original position

		clockwiseTurn(127);

		//////////////////////////*/

	}

	if(flag == 3)//Back Red
	{

		//New Auton Pseudocode: FILL IN ALL 'int' VALUES TO ADJUST FOR DISTANCES, INSTRUCTIONS ARE ALREADY GIVEN//////////

		//Posiion robot front facing the wall
		//Drive backwards into the cap
		resetMotorEncoders();
		driveBack(-500,-100,-30);
		resetMotorEncoders();

		//If cap does flip, raise arm to fip it back to our colour, if not, delete this step
		motor[Arm] = 127;
		wait1Msec(3000);
		motor[Arm] = -127;
		wait1Msec(3000);
		motor[Arm] = 0;

		//Turn to face platform (90 degree turn)
		resetMotorEncoders();
		while(nMotorEncoder[DriveR] > -450 && nMotorEncoder[DriveL] < 450){
			motor[DriveR] = -127;
			motor[DriveL] = 127;
		}
		resetMotorEncoders();

		//Drive backwards into 2nd cap
		resetMotorEncoders();
		driveBack(-300,-100,-30);
		resetMotorEncoders();

		//Raise arm to flip cap
		motor[Arm] = 127;
		wait1Msec(3000);
		motor[Arm] = -127;
		wait1Msec(3000);
		motor[Arm] = 0;

		//Tank turn 180 degrees to have back face platform
		resetMotorEncoders();
		while(nMotorEncoder[DriveR] > -900 && nMotorEncoder[DriveL] < 900){
			motor[DriveR] = -127;
			motor[DriveL] = 127;
		}
		resetMotorEncoders();

		//Drive backwards onto platform
		resetMotorEncoders();
		driveBack(-500,-100,-30);
		resetMotorEncoders();
	}

	if(flag == 4)//Back Blue
	{

		//New Auton Pseudocode: FILL IN ALL 'int' VALUES TO ADJUST FOR DISTANCES, INSTRUCTIONS ARE ALREADY GIVEN//////////

		//Posiion robot front facing the wall
		//Drive backwards into the cap
		resetMotorEncoders();
		driveBack(-500,-100,-30);
		resetMotorEncoders();

		//If cap does flip, raise arm to fip it back to our colour, if not, delete this step
		motor[Arm] = 127;
		wait1Msec(3000);
		motor[Arm] = -127;
		wait1Msec(3000);
		motor[Arm] = 0;

		//Turn to face platform (90 degree turn)
		resetMotorEncoders();
		while(nMotorEncoder[DriveR] < 450 && nMotorEncoder[DriveL] > -450){
			motor[DriveR] = 127;
			motor[DriveL] = -127;
		}
		resetMotorEncoders();

		//Drive backwards into 2nd cap
		resetMotorEncoders();
		driveBack(-300,-100,-30);
		resetMotorEncoders();

		//Raise arm to flip cap
		motor[Arm] = 127;
		wait1Msec(3000);
		motor[Arm] = -127;
		wait1Msec(3000);
		motor[Arm] = 0;

		//Tank turn 180 degrees to have back face platform
		resetMotorEncoders();
		while(nMotorEncoder[DriveR] < 900 && nMotorEncoder[DriveL] > -900){
			motor[DriveR] = 127;
			motor[DriveL] = -127;
		}
		resetMotorEncoders();

		//Drive backwards onto platform
		resetMotorEncoders();
		driveBack(-500,-100,-30);
		resetMotorEncoders();

		//Old Auton Code////////////////////

		/*resetMotorEncoders();

		driveStraight (950, 110, 30); //drive into front flag

		Suck(1250);

		resetMotorEncoders();

		driveBack (-500, -110, -30); //drive to original position

		resetMotorEncoders();

		counter_clockwiseTurn(110);

		resetMotorEncoders();

		driveBack(-500, -110, -30);

		resetMotorEncoders();

		counter_clockwiseTurn(110);

		resetMotorEncoders();

		driveBack(-500, -90, -30);*/

	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
		// This is the main execution loop for the user control program. Each time through the loop
		// your program should update motor + servo values based on feedback from the joysticks.

		// .....................................................................................
		// Insert user code here. This is where you use the joystick values to update your motors, etc.
		// .....................................................................................


		//Drive

		motor[DriveR] = vexRT[Ch2];
		motor[DriveL] = vexRT[Ch3];

		//Suck

		if(vexRT[Btn6U] == 1)
		{
			motor[SuckL] = 127;
			motor[SuckR] = 127;
			motor[Push] = 127;
		}

		else if(vexRT[Btn6D] == 1)
		{
			motor[SuckL] = -127;
			motor[SuckR] = -127;
		}

		else
		{
			motor[SuckL] = 0;
			motor[SuckR] = 0;
			motor[Push] = 0;
		}

		//Arm

		if(vexRT[Btn5U] == 1)
		{
			motor[Arm] = 50;
		}

		else if(vexRT[Btn5D] == 1)
		{
			motor[Arm] = -50;
		}

		else
		{
			motor[Arm] = 0;
		}

		//Puncher

		if(vexRT[Btn7D] == 1)
		{
			motor[Puncher] = 127;
		}
		else
		{
			motor[Puncher] = 0;
		}



	}
}
